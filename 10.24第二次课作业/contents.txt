目录结构:
|-- 文件: contents.py
|-- 文件: contents.txt
|-- 文件: T1.jl
|-- 文件: T2.jl
|-- 文件: T3.jl
|-- 文件: T3.py
|-- 文件: T4.jl
|-- 文件: T4.py
|-- 文件: Zbra0.jpg
|-- 文件: Zbra1.jpg
|-- 文件: 化工过程模拟及软件应用作业题-1.pdf
|-- 文件: 第一次作业（Typro作答）.md
|-- 文件: 第一次作业（Typro作答）.pdf


================================================================================
E:\LGRepository\Mworks.syslab\10.24HomeWork\T1.jl 的内容:
================================================================================
using TyBase
using TyMath
using TyPlot

# 定义计算费用的函数
function calculate_prices(n)
    if n == 1
        return 150.0
    elseif n == 2
        return 150.0 + 120.0
    elseif n >= 3
        return 150.0 + 120.0 + (n-2) * 110.0
    end
end

# 创建数量和对应价格的数组
n = [1:1:10;];
prices = Float64[];

# 循环计算购买1到10台的价格并将结果放到prices中
for i in n
    push!(prices, calculate_prices(i))
end

# 输出结果
prices_10 = prices[10];
print("购买 10 台设备的总价格为: ", prices_10, "\$")

# 绘制条形统计图
figure(figsize=(10, 6))  # 设置图形大小
bar(n, prices, color=:skyblue, edgecolor=:black, linewidth=1.5)

# 添加标签和标题
xlabel("设备数量/个", fontsize=14)
ylabel("所需价格/\$", fontsize=14)
title("购买设备的总价格", fontsize=16, fontweight="bold")
grid(true)  # 添加网格
xticks(n);  # 设置 x 轴刻度

================================================================================
E:\LGRepository\Mworks.syslab\10.24HomeWork\T2.jl 的内容:
================================================================================
using TyBase
using TyMath
using TyPlot
using TyCurveFitting
using Printf

t = [1:1:9;]
cA = vec([0.9 0.61 0.42 0.28 0.17 0.12 0.08 0.045 0.03]);

# 待插值查询的点
tq = vec([1.5, 2.4, 3.5, 4.6, 5.5, 6.4, 7.5, 8.7]);

# 两种不同的插值方式
cAq_linear = interp1(t, cA, tq, "linear");
cAq_spline = interp1(t, cA, tq, "spline");

# 输出结果，保留 6 位小数
println("线性插值所得结果:")
for value in cAq_linear
    @printf("%.6f\n", value)
end

println("样条插值所得结果:")
for value in cAq_spline
    @printf("%.6f\n", value)
end

# 另一种格式化输出方式
# println("线性插值所得结果:")
# println(join(map(x -> @sprintf("%.6f", x), caq_linear), "\n"))
# println("样条插值所得结果:")
# println(join(map(x -> @sprintf("%.6f", x), caq_spline), "\n"))

figure()
hold(true) # 确保后续绘制不会覆盖之前的图形
scatter(t, cA, 10, "k", label="原始数据")
scatter(tq, cAq_linear, 20, "b", marker="h", filled=true, label="线性插值")
scatter(tq, cAq_spline, 10, "g", marker="d", filled=true, label="样条插值")

# 添加图例
legend()

# 拟合一阶动力学方程
ln_cA = log.(cA)  # 计算自然对数

# 使用线性回归拟合 ln(cA) = kt + C
lin_fit = fit("poly", t, ln_cA, order=1)
params = lin_fit.params

# 提取 k 和 C
k = params[1]
C = params[2]

# 输出拟合参数
println("拟合参数:")
println("k: ", k)
println("C: ", C)

# 绘制拟合曲线
fit_curve = exp.(k .* t .+ C)  # 恢复到原始形式 cA = e^(kt + C)
plot(t, fit_curve, color="m", label="拟合曲线")
legend()

================================================================================
E:\LGRepository\Mworks.syslab\10.24HomeWork\T3.jl 的内容:
================================================================================
using TyBase
using TyMath
using TyPlot
using Printf

# 常量定义
const Pc = 11.28e6      # Pa
const Tc = 405.65       # K
const w = 0.2526        # 无量纲
const R = 8.314         # J/(mol·K)

# 定义 Pr 和 Tr 的网格数据（示例数据，请根据实际表格数据替换）
Pr_values = [0.2, 0.4, 0.6, 0.8, 1.0]       # 示例 Pr 网格
Tr_values = [1.0, 1.2, 1.4, 1.6, 1.8]       # 示例 Tr 网格

# 示例 Z0 和 Z1 表格数据 (Pr × Tr)，实际应用中，这些数据应来自于 NH₃ 的压缩因子表格
Z0_table = [
    1.1  1.09 1.07 1.05 1.03;
    1.0  0.99 0.97 0.95 0.93;
    0.9  0.89 0.87 0.85 0.83;
    0.8  0.79 0.77 0.75 0.73;
    0.7  0.69 0.67 0.65 0.63
]

Z1_table = [
    0.05 0.048 0.046 0.044 0.042;
    0.04 0.038 0.036 0.034 0.032;
    0.03 0.028 0.026 0.024 0.022;
    0.02 0.018 0.016 0.014 0.012;
    0.01 0.008 0.006 0.004 0.002
]

# 使用 meshgrid2 创建二维网格数据
Pr_grid, Tr_grid = meshgrid2(Pr_values, Tr_values)

# 定义二维插值函数
function get_Z(Pr, Tr, Pr_grid, Tr_grid, Z0_table, Z1_table, w)
    # 确保 Pr 和 Tr 是标量
    if !isscalar(Pr) || !isscalar(Tr)
        error("Pr 和 Tr 必须是标量")
    end
    
    # 使用 TyMath.interp2 进行二维插值
    Z0 = TyMath.interp2(Pr_grid, Tr_grid, Z0_table, Pr, Tr)
    Z1 = TyMath.interp2(Pr_grid, Tr_grid, Z1_table, Pr, Tr)
    
    # 确保 Z0 和 Z1 是标量
    Z0 = isscalar(Z0) ? Z0 : Z0[1]
    Z1 = isscalar(Z1) ? Z1 : Z1[1]
    
    Z = Z0 + w * Z1
    return Z
end

# 状态1已知
P1 = 2.03e6       # Pa
V1 = 2.83         # m³
T1 = 477.0        # K

# 对比压力和对比温度
Pr1 = P1 / Pc
Tr1 = T1 / Tc

# 获取状态1的 Z
Z_1th_state = get_Z(Pr1, Tr1, Pr_grid, Tr_grid, Z0_table, Z1_table, w)

# 计算物质的量 n
n = (P1 * V1) / (Z_1th_state * R * T1)

@printf("使用普维法计算得到的物质的量 n = %.6f mol\n", n)

# 终止条件
T2 = 448.6        # K
V2 = 0.142        # m³

# 计算状态2的摩尔体积
v2 = V2 / n

# 迭代求解状态2的 P2
# 初始化 P2 的猜测值，假设初始为理想气体情况
P2 = (n * R * T2) / V2

# 设置迭代参数
tolerance = 1e-6
max_iterations = 100
global iteration = 0
global diff = 1.0

while diff > tolerance && iteration < max_iterations
    global iteration += 1
    Pr2 = P2 / Pc
    Tr2 = T2 / Tc
    Z2 = get_Z(Pr2, Tr2, Pr_grid, Tr_grid, Z0_table, Z1_table, w)
    
    println("Debug: Z2 = ", Z2, " type: ", typeof(Z2))
    
    P2_new = (Z2 * R * T2) / v2
    global diff = abs(P2_new - P2) / P2
    global P2 = P2_new
    
    println("Debug: P2 = ", P2, " type: ", typeof(P2))
end

if iteration == max_iterations
    println("迭代未收敛。")
else
    @printf("\n使用普压法迭代试差计算得到的 P2 = %.6f MPa\n", P2 / 1e6)
    @printf("迭代次数: %d\n", iteration)
end

# 计算并打印其他参数
Z2_final = (P2 * v2) / (R * T2)
Pr2_final = P2 / Pc
Tr2_final = T2 / Tc

@printf("\n其他参数:\n")
@printf("v2 = %.6f m³/mol\n", v2)
@printf("Z2 = %.6f\n", Z2_final)
@printf("Pr2 = %.6f\n", Pr2_final)
@printf("Tr2 = %.6f\n", Tr2_final)


================================================================================
E:\LGRepository\Mworks.syslab\10.24HomeWork\T3.py 的内容:
================================================================================
import cv2
import numpy as np
import pandas as pd
import pytesseract
from PIL import Image

def preprocess_image(image_path):
    # 读取图像
    img = cv2.imread(image_path)
    
    # 转换为灰度图
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    
    # 二值化
    thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1]
    
    return thresh

def extract_table_data(image):
    # 使用Tesseract OCR提取文本
    text = pytesseract.image_to_string(image, config='--psm 6')
    
    # 将文本分割成行
    lines = text.strip().split('\n')
    
    # 解析数据
    data = []
    current_row = []
    for i, line in enumerate(lines, 1):
        values = line.split()
        if values:
            current_row.extend(values)
        
        if i % 5 == 0:
            data.append(current_row)
            current_row = []
    
    if current_row:  # 添加最后一行（如果有的话）
        data.append(current_row)
    
    return data

def process_image(image_path):
    # 预处理图像
    preprocessed_image = preprocess_image(image_path)
    
    # 提取表格数据
    table_data = extract_table_data(preprocessed_image)
    
    # 创建DataFrame
    df = pd.DataFrame(table_data)
    
    return df

# 主程序
image_paths = ['Zbra0.jpg', 'Zbra1.jpg']

for i, path in enumerate(image_paths):
    # 处理图像并提取数据
    df = process_image(path)
    
    # 保存CSV
    csv_filename = f'Z{i}_data.csv'
    df.to_csv(csv_filename, index=False, header=False)
    print(f"数据已保存到 {csv_filename}")

print("处理完成")


================================================================================
E:\LGRepository\Mworks.syslab\10.24HomeWork\T4.jl 的内容:
================================================================================
using TyBase
using TyMath
using TyOptimization
using TyPlot
using Printf

# 动力学模型函数
function kinetic_model(res_opt, p)
    k, KB = res_opt
    n = length(p) ÷ 2
    # 分解 p 为 pA 和 pB
    pA = p[1:n]
    pB = p[n+1:end]
    return @. (k * pA * pB) / (1 + KB * pB)^2
end

# 实验数据
pA = [8.99, 14.22, 8.86, 8.32, 4.37, 7.75, 7.75, 6.17, 6.13, 6.98, 2.87] .* 1e-3  # 转换为 MPa
pB = [3.23, 3.00, 4.08, 2.03, 0.89, 1.74, 1.82, 1.73, 1.73, 1.56, 1.06] .* 1e-3  # 转换为 MPa
r = [0.672, 1.072, 0.598, 0.713, 0.610, 0.834, 0.828, 0.656, 0.694, 0.791, 0.418] .* 1e-4  # 转换为 mol/g.min

# 将 pA 和 pB 合并为一个一维数组
p = vcat(pA, pB)

# 参数上下界
lb = [0.0, 0.0]
ub = [Inf, Inf]

# 网格搜索范围
k_values = range(1.0, stop=1000.0, length=100)
KB_values = range(1.0, stop=2000.0, length=1000)

# 设定R²阈值
threshold_R_squared = 0.95

# 初始化最佳结果
global best_R_squared = -Inf
global best_params = nothing
global best_resnorm = Inf

# 网格搜索
for k_init in k_values
    for KB_init in KB_values
        local initial_params = [k_init, KB_init]
        local res_opt, resnorm = lsqcurvefit(kinetic_model, initial_params, p, r, lb, ub)
        
        # 计算 R²
        local predicted_r = kinetic_model(res_opt, p)
        local ss_res = sum((r - predicted_r).^2)
        local ss_tot = sum((r .- mean(r)).^2)
        local R_squared = 1 - ss_res / ss_tot
        
        # 更新最佳结果
        if R_squared > best_R_squared
            global best_R_squared = R_squared
            global best_params = res_opt
            global best_resnorm = resnorm
        end
        
        # 如果达到阈值，则停止搜索
        if best_R_squared >= threshold_R_squared
            break
        end
    end
    if best_R_squared >= threshold_R_squared
        break
    end
end

# 打印最佳结果
@printf("最佳拟合参数:\n")
@printf("k = %.6f\n", best_params[1])
@printf("KB = %.6f\n", best_params[2])
@printf("最佳 R² = %.6f\n", best_R_squared)
@printf("最佳残差范数: %.6e\n", best_resnorm)

# 绘制拟合结果
figure()
scatter3(pA, pB, r, label="实验数据")
xlabel("pA (MPa)")
ylabel("pB (MPa)")
zlabel("反应速率 (mol/g.min)")

pA_range = range(minimum(pA), stop=maximum(pA), length=50)
pB_range = range(minimum(pB), stop=maximum(pB), length=50)
fitted_surface = [kinetic_model(best_params, [pA, pB])[1] for pA in pA_range, pB in pB_range]
surface(pA_range, pB_range, fitted_surface, alpha=0.5, label="拟合曲面")
plt_view(40, 35)


================================================================================
E:\LGRepository\Mworks.syslab\10.24HomeWork\T4.py 的内容:
================================================================================
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

# 设置中文显示
plt.rcParams['font.sans-serif'] = ['SimHei']  # 使用黑体
plt.rcParams['axes.unicode_minus'] = False  # 正常显示负号

# 实验数据
pA = np.array([8.99, 14.22, 8.86, 8.32, 4.37, 7.75, 7.75, 6.17, 6.13, 6.98, 2.87]) * 1e-3  # MPa
pB = np.array([3.23, 3.00, 4.08, 2.03, 0.89, 1.74, 1.82, 1.73, 1.73, 1.56, 1.06]) * 1e-3  # MPa
r = np.array([0.672, 1.072, 0.598, 0.713, 0.610, 0.834, 0.828, 0.656, 0.694, 0.791, 0.418]) * 1e-4  # mol/g·min

# 定义动力学方程
def kinetics(X, k, KB):
    pA, pB = X
    return k * pA * pB / (1 + KB * pB)**2

# 执行曲线拟合
initial_guess = [1.0, 1.0]
params, covariance = curve_fit(kinetics, (pA, pB), r, p0=initial_guess)

# 输出拟合结果
k, KB = params
print(f"拟合参数:\nk = {k:.6e}\nKB = {KB:.6e}")

# 计算拟合后的速率
r_fitted = kinetics((pA, pB), *params)

# 计算R²
SS_tot = np.sum((r - np.mean(r))**2)
SS_res = np.sum((r - r_fitted)**2)
R_squared = 1 - SS_res / SS_tot
print(f"R² = {R_squared:.4f}")

# 绘制散点图
plt.figure(figsize=(8, 6))
plt.scatter(range(1, len(r) + 1), r * 1e4, label="实验数据", marker='o')
plt.scatter(range(1, len(r_fitted) + 1), r_fitted * 1e4, label="拟合数据", marker='s')
plt.xlabel("数据点")
plt.ylabel("反应速率 r (10$^{-4}$ mol/g·min)")
plt.title("乙烯深度氧化反应速率拟合结果")
plt.legend()
plt.grid(True)
plt.show()

